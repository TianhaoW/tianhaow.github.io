<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Dispersive Prism</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0f172a; /* Slate 900 */
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; /* Prevent scrolling on mobile */
        }
        canvas {
            display: block;
        }
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255,255,255,0.1);
        }
        .instruction {
            margin-bottom: 5px;
            font-size: 14px;
            color: #e2e8f0;
        }
        .key {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 5px;
            vertical-align: middle;
        }
    </style>
</head>
<body>

    <div class="controls">
        <h1 class="text-xl font-bold mb-2">Dispersive Prism</h1>
        <div class="instruction"><span class="text-cyan-400 font-bold">Drag</span> the Prism to move it</div>
        <div class="instruction"><span class="text-purple-400 font-bold">Rotate</span> by dragging prism corners</div>
        <div class="instruction"><span class="text-yellow-400 font-bold">Move/Aim</span> the Light Source</div>
    </div>

    <canvas id="simCanvas"></canvas>

<script>
/**
 * Vector Math Helpers
 */
class Vec2 {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }

    add(v) { return new Vec2(this.x + v.x, this.y + v.y); }
    sub(v) { return new Vec2(this.x - v.x, this.y - v.y); }
    mult(n) { return new Vec2(this.x * n, this.y * n); }
    mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    normalize() {
        const m = this.mag();
        return m === 0 ? new Vec2(0, 0) : new Vec2(this.x / m, this.y / m);
    }
    dot(v) { return this.x * v.x + this.y * v.y; }
    rotate(angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        return new Vec2(
            this.x * cos - this.y * sin,
            this.x * sin + this.y * cos
        );
    }
}

/**
 * Constants & Config
 */
const WAVELENGTHS = [
    { color: '#ff0000', n: 1.30 }, // Red (Low index)
    { color: '#ff7f00', n: 1.33 },
    { color: '#ffff00', n: 1.36 },
    { color: '#00ff00', n: 1.39 },
    { color: '#0000ff', n: 1.42 },
    { color: '#4b0082', n: 1.45 },
    { color: '#9400d3', n: 1.48 }  // Violet (High index - Exaggerated for visibility)
];

// Canvas Setup
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
let width, height;

// State
const state = {
    prism: {
        x: 0,
        y: 0,
        radius: 120,
        angle: 0,
        dragging: false,
        rotating: false
    },
    light: {
        x: 0,
        y: 0,
        angle: 0,
        draggingBody: false,
        draggingHead: false
    }
};

/**
 * Initialization
 */
function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    // Initial positions if not set
    if (state.prism.x === 0) {
        state.prism.x = width * 0.6;
        state.prism.y = height * 0.5;
        state.light.x = width * 0.2;
        state.light.y = height * 0.5;
    }
}
window.addEventListener('resize', resize);
resize();

/**
 * Geometry Functions
 */
function getPrismVertices() {
    const verts = [];
    for (let i = 0; i < 3; i++) {
        // Equilateral triangle
        const theta = state.prism.angle + (i * 2 * Math.PI / 3) - (Math.PI / 2);
        verts.push(new Vec2(
            state.prism.x + Math.cos(theta) * state.prism.radius,
            state.prism.y + Math.sin(theta) * state.prism.radius
        ));
    }
    return verts;
}

// Ray-Line Intersection
// Returns { point: Vec2, t: number } or null
function getIntersection(rayOrigin, rayDir, p1, p2) {
    const v1 = rayOrigin;
    const v2 = rayOrigin.add(rayDir);
    const v3 = p1;
    const v4 = p2;

    const denom = (v1.x - v2.x) * (v3.y - v4.y) - (v1.y - v2.y) * (v3.x - v4.x);
    if (denom === 0) return null;

    const t = ((v1.x - v3.x) * (v3.y - v4.y) - (v1.y - v3.y) * (v3.x - v4.x)) / denom;
    const u = -((v1.x - v2.x) * (v1.y - v3.y) - (v1.y - v2.y) * (v1.x - v3.x)) / denom;

    if (t >= 0 && u >= 0 && u <= 1) {
        const pt = new Vec2(
            v1.x + t * (v2.x - v1.x),
            v1.y + t * (v2.y - v1.y)
        );
        return { point: pt, dist: t, normal: new Vec2(-(p2.y - p1.y), p2.x - p1.x).normalize() };
    }
    return null;
}

/**
 * Physics Core
 */
function solveRay(origin, direction, wIndex, depth = 0) {
    if (depth > 5) return []; // Recursion limit

    const verts = getPrismVertices();
    let closestInfo = null;
    let closestDist = Infinity;
    let hitIndex = -1;

    // Check intersection with all 3 faces
    for (let i = 0; i < 3; i++) {
        const p1 = verts[i];
        const p2 = verts[(i + 1) % 3];

        const hit = getIntersection(origin, direction, p1, p2);

        // We need a small epsilon for self-intersection avoidance
        if (hit && hit.dist > 0.1 && hit.dist < closestDist) {
            closestDist = hit.dist;
            closestInfo = hit;
            hitIndex = i;
        }
    }

    // If no hit, ray goes to infinity (screen edge)
    if (!closestInfo) {
        return [{ start: origin, end: origin.add(direction.mult(2000)) }];
    }

    const hitPoint = closestInfo.point;
    let normal = closestInfo.normal;

    // Check entering or exiting
    // If ray direction and normal are opposite, we are entering
    const entering = direction.dot(normal) < 0;

    // Ratios of refractive indices
    let n1 = 1.0; // Air
    let n2 = wIndex.n; // Prism

    if (!entering) {
        // Exiting: flip indices and flip normal for math
        [n1, n2] = [n2, n1];
        normal = normal.mult(-1);
    }

    // Snell's Law
    // n1 * sin(theta1) = n2 * sin(theta2)
    // Vector form: r_out = (n1/n2) * (r_in - dot(N, r_in)*N) - N * sqrt(1 - (n1/n2)^2 * (1 - dot(N, r_in)^2))

    const r = n1 / n2;
    const c = -normal.dot(direction);
    const k = 1 - r * r * (1 - c * c);

    let nextPath = [];

    if (k < 0) {
        // Total Internal Reflection (TIR)
        // Reflection vector: R = D - 2(D.N)N
        const reflectDir = direction.sub(normal.mult(2 * direction.dot(normal))).normalize();
        nextPath = solveRay(hitPoint, reflectDir, wIndex, depth + 1);
    } else {
        // Refraction
        const refractDir = direction.mult(r).add(normal.mult(r * c - Math.sqrt(k))).normalize();
        nextPath = solveRay(hitPoint, refractDir, wIndex, depth + 1);
    }

    return [{ start: origin, end: hitPoint }, ...nextPath];
}


/**
 * Drawing
 */
function draw() {
    // Clear
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, width, height);

    // --- Draw Light Source ---
    const lightDir = new Vec2(Math.cos(state.light.angle), Math.sin(state.light.angle));
    const lightPos = new Vec2(state.light.x, state.light.y);

    // Draw Beam (White part)
    // We trace one ray for white light up to the prism surface
    const verts = getPrismVertices();
    let firstHit = null;
    let closestDist = Infinity;

    for (let i = 0; i < 3; i++) {
        const p1 = verts[i];
        const p2 = verts[(i + 1) % 3];
        const hit = getIntersection(lightPos, lightDir, p1, p2);
        if (hit && hit.dist < closestDist && hit.dist > 0) {
            closestDist = hit.dist;
            firstHit = hit;
        }
    }

    const whiteEnd = firstHit ? firstHit.point : lightPos.add(lightDir.mult(2000));

    // Draw White Beam
    ctx.beginPath();
    ctx.moveTo(lightPos.x, lightPos.y);
    ctx.lineTo(whiteEnd.x, whiteEnd.y);
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 4;
    ctx.shadowBlur = 10;
    ctx.shadowColor = 'white';
    ctx.globalCompositeOperation = 'screen';
    ctx.stroke();
    ctx.shadowBlur = 0;
    ctx.globalCompositeOperation = 'source-over';

    // --- Draw Dispersion (if hitting prism) ---
    if (firstHit) {
        // For each wavelength, calculate path starting from entry point
        WAVELENGTHS.forEach(wl => {
            // Slight nudge into the prism to prevent self-intersection immediately
            const nudge = lightDir.mult(0.1);
            const pathSegments = solveRay(whiteEnd.add(nudge), lightDir, wl);

            ctx.beginPath();
            // Start exactly at entry
            ctx.moveTo(whiteEnd.x, whiteEnd.y);

            pathSegments.forEach(seg => {
                ctx.lineTo(seg.end.x, seg.end.y);
            });

            ctx.strokeStyle = wl.color;
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.8;
            ctx.globalCompositeOperation = 'screen'; // Blend colors nicely
            ctx.stroke();
        });
        ctx.globalAlpha = 1.0;
        ctx.globalCompositeOperation = 'source-over';
    }


    // --- Draw Prism ---
    ctx.beginPath();
    ctx.moveTo(verts[0].x, verts[0].y);
    ctx.lineTo(verts[1].x, verts[1].y);
    ctx.lineTo(verts[2].x, verts[2].y);
    ctx.closePath();

    // Glassy look
    const grad = ctx.createLinearGradient(verts[0].x, verts[0].y, verts[1].x, verts[1].y);
    grad.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
    grad.addColorStop(1, 'rgba(255, 255, 255, 0.05)');
    ctx.fillStyle = grad;
    ctx.fill();
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Corner handles (for rotation)
    verts.forEach(v => {
        ctx.beginPath();
        ctx.arc(v.x, v.y, 6, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(168, 85, 247, 0.6)'; // Purple
        ctx.fill();
    });
    // Center handle
    ctx.beginPath();
    ctx.arc(state.prism.x, state.prism.y, 5, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(34, 211, 238, 0.5)'; // Cyan
    ctx.fill();


    // --- Draw Flashlight Body UI ---
    ctx.save();
    ctx.translate(state.light.x, state.light.y);
    ctx.rotate(state.light.angle);

    // Body
    ctx.fillStyle = '#64748b';
    ctx.fillRect(-40, -10, 40, 20);
    // Head (Draggable for angle)
    ctx.fillStyle = '#94a3b8'; // Lighter
    ctx.beginPath();
    ctx.moveTo(0, -10);
    ctx.lineTo(10, -15);
    ctx.lineTo(10, 15);
    ctx.lineTo(0, 10);
    ctx.fill();

    // Highlight interaction point
    ctx.beginPath();
    ctx.arc(10, 0, 4, 0, Math.PI*2);
    ctx.fillStyle = '#facc15';
    ctx.fill();

    ctx.restore();

    requestAnimationFrame(draw);
}


/**
 * Input Handling
 */
function getMousePos(e) {
    const rect = canvas.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    return new Vec2(clientX - rect.left, clientY - rect.top);
}

function onDown(e) {
    const pos = getMousePos(e);

    // 1. Check Light Head (Rotation)
    const lightDir = new Vec2(Math.cos(state.light.angle), Math.sin(state.light.angle));
    const headPos = new Vec2(state.light.x, state.light.y).add(lightDir.mult(10));
    if (pos.sub(headPos).mag() < 20) {
        state.light.draggingHead = true;
        return;
    }

    // 2. Check Light Body (Movement)
    if (pos.sub(new Vec2(state.light.x, state.light.y)).mag() < 30) {
        state.light.draggingBody = true;
        return;
    }

    // 3. Check Prism Rotation (Vertices)
    const verts = getPrismVertices();
    for(let v of verts) {
        if (pos.sub(v).mag() < 20) {
            state.prism.rotating = true;
            // Calculate initial angle offset for smooth rotation
            state.prism.rotationOffset = Math.atan2(pos.y - state.prism.y, pos.x - state.prism.x) - state.prism.angle;
            return;
        }
    }

    // 4. Check Prism Center (Movement)
    if (pos.sub(new Vec2(state.prism.x, state.prism.y)).mag() < 40) {
        state.prism.dragging = true;
        return;
    }
}

function onMove(e) {
    const pos = getMousePos(e);

    if (state.light.draggingHead) {
        state.light.angle = Math.atan2(pos.y - state.light.y, pos.x - state.light.x);
    }
    else if (state.light.draggingBody) {
        state.light.x = pos.x;
        state.light.y = pos.y;
    }
    else if (state.prism.dragging) {
        state.prism.x = pos.x;
        state.prism.y = pos.y;
    }
    else if (state.prism.rotating) {
        const currentMouseAngle = Math.atan2(pos.y - state.prism.y, pos.x - state.prism.x);
        state.prism.angle = currentMouseAngle - state.prism.rotationOffset;
    }

    // Cursor styling
    const verts = getPrismVertices();
    const lightHeadPos = new Vec2(state.light.x, state.light.y).add(new Vec2(Math.cos(state.light.angle), Math.sin(state.light.angle)).mult(10));

    let cursor = 'default';
    if (pos.sub(lightHeadPos).mag() < 20) cursor = 'crosshair';
    else if (pos.sub(new Vec2(state.light.x, state.light.y)).mag() < 30) cursor = 'move';
    else if (pos.sub(new Vec2(state.prism.x, state.prism.y)).mag() < 40) cursor = 'move';
    else if (verts.some(v => pos.sub(v).mag() < 20)) cursor = 'grab';

    canvas.style.cursor = cursor;
}

function onUp() {
    state.prism.dragging = false;
    state.prism.rotating = false;
    state.light.draggingBody = false;
    state.light.draggingHead = false;
}

canvas.addEventListener('mousedown', onDown);
window.addEventListener('mousemove', onMove);
window.addEventListener('mouseup', onUp);

canvas.addEventListener('touchstart', (e) => { e.preventDefault(); onDown(e); }, {passive: false});
window.addEventListener('touchmove', (e) => { e.preventDefault(); onMove(e); }, {passive: false});
window.addEventListener('touchend', onUp);

// Start Loop
draw();

</script>
</body>
</html>